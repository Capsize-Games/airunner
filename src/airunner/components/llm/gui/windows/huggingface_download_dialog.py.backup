"""Dialog for showing HuggingFace model download progress."""

import os
from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QProgressBar,
    QTextEdit,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QAbstractScrollArea,
)
from PySide6.QtCore import Qt, Slot, Signal

from airunner.components.application.gui.windows.main.settings_mixin import (
    SettingsMixin,
)
from airunner.utils.application.mediator_mixin import MediatorMixin
from airunner.enums import SignalCode


class HuggingFaceDownloadDialog(MediatorMixin, SettingsMixin, QDialog):
    """
    Modal dialog for showing HuggingFace model download progress.

    Features:
    - Progress bar showing overall download progress
    - Log display showing per-file progress
    - Cancel button to abort download
    - Auto-closes on successful completion
    """

    def __init__(self, parent, model_name: str, model_path: str):
        """
        Initialize the download dialog.

        Args:
            parent: Parent widget
            model_name: Display name of model being downloaded
            model_path: Path where model will be saved
        """
        # Set up signal handlers before calling super().__init__
        # MediatorMixin will automatically register them
        self.signal_handlers = {
            SignalCode.UPDATE_DOWNLOAD_PROGRESS: self.on_progress_updated,
            SignalCode.UPDATE_FILE_DOWNLOAD_PROGRESS: self.on_file_progress_updated_from_signal,
            SignalCode.UPDATE_DOWNLOAD_LOG: self.on_log_updated,
            SignalCode.HUGGINGFACE_DOWNLOAD_COMPLETE: self.on_download_complete,
            SignalCode.HUGGINGFACE_DOWNLOAD_FAILED: self.on_download_failed,
        }
        super().__init__(parent=parent)

        self.model_name = model_name
        self.model_path = model_path
        self._last_progress = -1
        self._progress_started = False
        self._file_progress_bars = {}  # Map filename -> progress bar widget

        self.setWindowTitle("Downloading Model")
        self.setMinimumSize(700, 600)
        self.setWindowModality(Qt.WindowModality.ApplicationModal)

        self._setup_ui()

    def _setup_ui(self) -> None:
        """Setup the UI components."""
        layout = QVBoxLayout(self)

        # Title label
        title = QLabel(f"Downloading {self.model_name}")
        title.setStyleSheet("font-size: 14pt; font-weight: bold;")
        layout.addWidget(title)

        # Path label
        path_label = QLabel(f"Destination: {self.model_path}")
        path_label.setWordWrap(True)
        layout.addWidget(path_label)

        # Overall progress section
        overall_label = QLabel("Overall Progress:")
        overall_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(overall_label)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 0)  # Start as indeterminate/busy
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("Initializing download...")
        layout.addWidget(self.progress_bar)

        # Download stats label (speed, bytes transferred)
        self.stats_label = QLabel("Preparing to download...")
        self.stats_label.setStyleSheet("color: #888; font-size: 9pt;")
        layout.addWidget(self.stats_label)

        # Per-file progress table
        file_progress_label = QLabel("File Progress:")
        file_progress_label.setStyleSheet(
            "font-weight: bold; margin-top: 10px;"
        )
        layout.addWidget(file_progress_label)

        self.file_table = QTableWidget()
        self.file_table.setColumnCount(2)
        self.file_table.setHorizontalHeaderLabels(["Filename", "Progress"])
        header = self.file_table.horizontalHeader()
        header.setStretchLastSection(False)
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.file_table.setAlternatingRowColors(True)
        self.file_table.setMinimumHeight(240)
        self.file_table.setSizeAdjustPolicy(
            QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents
        )
        self.file_table.verticalHeader().setVisible(False)
        self.file_table.setSelectionMode(
            QTableWidget.SelectionMode.NoSelection
        )
        self.file_table.verticalHeader().setDefaultSectionSize(24)
        layout.addWidget(self.file_table)

        # Log display
        log_label = QLabel("Download Log:")
        log_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(log_label)

        self.log_display = QTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setMaximumHeight(150)
        layout.addWidget(self.log_display)

        # Cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.on_cancel_clicked)
        layout.addWidget(self.cancel_button)

    def on_progress_updated(self, data: dict) -> None:
        """
        Update progress bar.

        Args:
            data: Dict with 'progress' key (0-100, float)
        """
        progress = data.get("progress", 0.0)

        if progress <= 0:
            self.stats_label.setText("Preparing to download...")

        # Switch from indeterminate to determinate progress on first update
        if not self._progress_started and progress > 0:
            self._progress_started = True
            self.progress_bar.setRange(0, 1000)
            self.stats_label.setText("Downloading...")

        # Only update if progress changed to avoid unnecessary redraws
        if abs(progress - self._last_progress) >= 0.01:
            self._last_progress = progress
            scaled_value = min(1000, int(round(progress * 10.0)))
            self.progress_bar.setValue(scaled_value)
            self.progress_bar.setFormat(f"{progress:.1f}%")

            # Update stats label with progress
            if progress < 100:
                self.stats_label.setText(
                    f"Downloading... {progress:.1f}% complete"
                )
            else:
                self.stats_label.setText("Download complete!")

    def on_file_progress_updated_from_signal(self, data: dict) -> None:
        """
        Handle file progress update from signal mediator.

        Args:
            data: Dict with 'filename', 'downloaded', and 'total' keys
        """
        filename = data.get("filename", "")
        downloaded = data.get("downloaded", 0)
        total = data.get("total", 0)

        # Add file to table if not already present
        if filename not in self._file_progress_bars:
            row = self.file_table.rowCount()
            self.file_table.insertRow(row)

            # Filename column
            name_item = QTableWidgetItem(filename)
            name_item.setFlags(name_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.file_table.setItem(row, 0, name_item)

            # Progress bar column
            progress_bar = QProgressBar()
            progress_bar.setRange(0, 1000)
            progress_bar.setValue(0)
            progress_bar.setTextVisible(True)
            progress_bar.setFormat("0.0%")
            self.file_table.setCellWidget(row, 1, progress_bar)
            self.file_table.setRowHeight(
                row, max(progress_bar.sizeHint().height(), 22)
            )
            self.file_table.resizeRowToContents(row)

            self._file_progress_bars[filename] = progress_bar

        # Update progress bar
        progress_bar = self._file_progress_bars[filename]
        if total > 0:
            percent = min(100.0, (downloaded * 100.0) / total)
            scaled_value = min(1000, int(round(percent * 10.0)))
            progress_bar.setValue(scaled_value)
            progress_bar.setFormat(f"{percent:.1f}%")

    def on_log_updated(self, data: dict) -> None:
        """
        Append message to log display.

        Args:
            data: Dict with 'message' key
        """
        message = data.get("message", "")
        if message:
            self.log_display.append(message)
            # Auto-scroll to bottom
            scrollbar = self.log_display.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())

    def on_download_complete(self, data: dict) -> None:
        """
        Handle successful download completion.

        Args:
            data: Dict with completion info
        """
        self.log_display.append("\nâœ“ Download complete!")
        self.log_display.append("Preparing model for use...")
        self.progress_bar.setValue(1000)
        self.cancel_button.setEnabled(False)

        # Auto-close after a brief delay
        from PySide6.QtCore import QTimer

        QTimer.singleShot(1500, self.accept)

    def on_download_failed(self, data: dict) -> None:
        """
        Handle download failure.

        Args:
            data: Dict with 'error' key
        """
        error = data.get("error", "Unknown error")
        self.log_display.append(f"\nâœ— Download failed: {error}")

        # Check if it's a 401 Unauthorized error
        if "401" in str(error) and "Unauthorized" in str(error):
            # Check if API key is already configured
            from airunner.utils.settings.get_qsettings import get_qsettings

            settings = get_qsettings()
            api_key = settings.value("huggingface/api_key", "")

            if not api_key:
                # No API key - show settings dialog to enter it
                self.log_display.append("\nâš  Authentication required!")
                self.log_display.append(
                    "You need to configure your HuggingFace API key."
                )
                self.cancel_button.setText("Close")

                # Show HuggingFace settings dialog
                from PySide6.QtCore import QTimer

                QTimer.singleShot(1500, self._show_huggingface_settings)
            else:
                # API key exists but still getting 401 - likely needs repo access
                self.log_display.append("\nâš  Access denied!")
                self.log_display.append(
                    "You have an API key configured, but access was denied."
                )
                self.log_display.append(
                    "\nThis model may require you to accept a license agreement."
                )
                self.log_display.append(
                    "Please visit the model page on HuggingFace"
                )
                self.log_display.append(
                    "and click 'Agree and access repository' if prompted."
                )
                self.cancel_button.setText("Close")
        else:
            self.cancel_button.setText("Close")

    def _show_huggingface_settings(self) -> None:
        """Show HuggingFace settings dialog and retry download if accepted."""
        from PySide6.QtWidgets import (
            QDialog,
            QVBoxLayout,
            QLabel,
            QDialogButtonBox,
        )
        from airunner.components.settings.gui.widgets.huggingface_settings.huggingface_settings_widget import (
            HuggingfaceSettingsWidget,
        )

        # Create settings dialog
        dialog = QDialog(self.parent())
        dialog.setWindowTitle("HuggingFace API Key Required")
        dialog.setMinimumSize(500, 250)

        layout = QVBoxLayout(dialog)

        # Add explanation
        explanation = QLabel(
            "This model requires authentication with HuggingFace.\n\n"
            "Please enter your HuggingFace API key below, then click OK to retry the download:"
        )
        explanation.setWordWrap(True)
        layout.addWidget(explanation)

        # Add the HuggingFace settings widget
        settings_widget = HuggingfaceSettingsWidget()
        layout.addWidget(settings_widget)

        # Add OK/Cancel buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok
            | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        # Show the dialog and check result
        result = dialog.exec()

        if result == QDialog.Accepted and self.download_manager:
            # User clicked OK, retry the download
            self.log_display.append(
                "\nðŸ”„ Retrying download with authentication..."
            )
            self.cancel_button.setText("Cancel")
            self.cancel_button.setEnabled(True)

            # Restart the download
            self.download_manager.download(
                repo_id=self.download_manager.repo_id,
                model_type=self.download_manager.model_type,
                output_dir=self.download_manager.output_dir,
                setup_quantization=self.download_manager.setup_quantization,
                quantization_bits=self.download_manager.quantization_bits,
            )
        else:
            # User cancelled, close the download dialog
            self.reject()

    def on_cancel_clicked(self) -> None:
        """Handle cancel button click."""
        self.log_display.append("\nCancelling download...")
        # Emit signal to cancel download
        self.emit_signal(SignalCode.CANCEL_HUGGINGFACE_DOWNLOAD, {})
        self.cancel_button.setEnabled(False)
        self.reject()

    def closeEvent(self, event) -> None:
        """Handle dialog close event."""
        # Cancel download if still running
        self.emit_signal(SignalCode.CANCEL_HUGGINGFACE_DOWNLOAD, {})
        super().closeEvent(event)
