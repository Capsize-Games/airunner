from transformers import LocalAgent as LocalAgentBase

from transformers.tools.agents import clean_code_for_run, resolve_tools, get_tool_creation_code
from transformers.tools.python_interpreter import evaluate


class LocalAgent(LocalAgentBase):
    def __init__(self, *args, **kwargs):
        self.restrict_tools_to_additional = kwargs.pop("restrict_tools_to_additional", False)
        super().__init__(*args, **kwargs)
        if self.restrict_tools_to_additional:
            self._toolbox = kwargs.get("additional_tools")

    def format_prompt(self, task, chat_mode=False):
        task = super().format_prompt(task, chat_mode=chat_mode)
        task = task.replace("</s>", "")
        return task

    def run(self, task, *, return_code=False, remote=False, **kwargs):
        prompt = self.format_prompt(task)
        result = self.generate_one(prompt, stop=["Task:"])
        explanation, code = clean_code_for_run(result)

        self.log(f"==Explanation from the agent==\n{explanation}")

        """
        This entire class exists as a work around in order
        to run the following line of code. Without this, the evaluation
        will fail with Mistral Instruct (possibly with other models as well) 
        """
        code = code.replace("```", "").replace("</s>", "")
        code = code.replace("<|endoftext|>", "")

        self.log(f"\n\n==Code generated by the agent==\n{code}")
        if not return_code:
            self.log("\n\n==Result==")
            self.cached_tools = resolve_tools(code, self.toolbox, remote=remote, cached_tools=self.cached_tools)
            return evaluate(code, self.cached_tools, state=kwargs.copy())
        else:
            tool_code = get_tool_creation_code(code, self.toolbox, remote=remote)
            return f"{tool_code}\n{code}"
